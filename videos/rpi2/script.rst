================================================================================
NixOS 73: Building a NixOS Image for Raspberry Pi, Pt. 2 (Updating a Running Pi)
================================================================================

Recap
=====

In `part 1 of this series <https://youtu.be/9W6znVpxn1c>`_ (talky script at
https://github.com/mcdonc/.nixconfig/blob/master/videos/rpi/script.rst), I got
a Pi Zero 2 W booting to NixOS after using a Nix flake to generate an image
file which I burned to an SD card.  I made sure wireless and HDMI worked.

In this video, I'll be solidifying the methods that we can use to update NixOS
on a Pi after we get it running.

In the first video, I used only a Pi Zero 2 W.  In the meantime, I've confirmed
that the SD card image generated by the repository will boot each of a Pi Zero
2 W, a Pi 3 and Pi 4 fine.  Wireless and USB (at least a USB keyboard) work on
all of those.  I'll be using both a Pi Zero 2 W and a Pi 4 during this video.
I have not tested anything on a Pi 5 but it should work.

I will (still) not be testing GPIO, Bluetooth, Ethernet or sound in this video.
Those will have to wait for another video.

Solved Mysteries and Added Conveniences
=======================================

In the first video, I ran across some mysteries and I did some inconvenient
things.

Automatic Booting
-----------------

In the first video, had an issue with the Zero 2 W not automatically booting.
I had to type ``boot`` on its console for it to start to boot Linux.  I thought
it might be an issue with that specific Zero 2 W, because it has been through
some tough times, but the issue actually turned out to be due to which devices
I have plugged into which of its micro USB ports.  If I plug the keyboard into
the micro USB closer to the HDMI, and the power into the the micro USB further
away from the HDMI, it will not boot.  If I reverse those, it boots fine.  Here
is the right orientation to allow a boot:

.. image:: orientation.jpg

This is true of a second Pi Zero 2 W I tried as well, so likely every Pi Zero 2
W is this way.

Building on non-NixOS
---------------------

You can indeed use Ubuntu (with Nix on it) to build an image (I did it).  The
instructions are no different than those given in part 1, save for installing
Nix onto your Ubuntu machine first.

I did not try MacOS (nor, I've decided, will I).

Updating a running Pi remotely using non-NixOS may be a bit of a different
story.  In general, it's best to use NixOS as the system to generate an image
and update the running Pi later if you update remotely.  It's possible to use
other operating systems for this, but for sake of video brevity and research
time, I won't be going into any detail about doing it on non-NixOS.

Using ``dd`` rather than Balena Etcher
--------------------------------------

I used Balena Etcher to write the image to an SD card the last time because it
seemed convenient, but it's not really if you're doing it a lot.

Instead, you can use ``dd``.  Issue this command (replace ``/dev/mysdcard``
with ``/dev/sda`` or ``/dev/sdb`` or whatever your card is present on) after
building the image as detailed in part 1::

  sudo dd if=result/sd-image/zero2.img of=/dev/mysdcard bs=1M conv=fsync status=progress

Note that NixOS automatically resizes the root partition to the entirety of the
SD card's free space upon first boot, no matter which burning method you use.

ZRAM
----

I've tried to give the booted system a little more headroom by increasing the
amount of compressed RAM swap space.

Solving Today's Mystery: Updating the Pi as It's Running
========================================================

You can either generate configuration files and manage the Pi standalone like
any other NixOS system, or use ``deploy-rs`` to manage it remotely.

Using Pi-Local Configuration Files
----------------------------------

Run ``sudo nixos-generate-config`` to generate ``/etc/configuration.nix`` and
``/etc/hardware-configuration.nix``.

Copy the stuff from host's ``nixos-pi-zero-2-w/zero2w.nix`` into Pi's
``/etc/configuration.nix`` to match the current state of the system.  Get rid
of ``sdImage`` stuff and ``nixpkgs.hostPlatform.system`` /
``nixpkgs.buildPlatform.system`` and include ``./hardware-configuration.nix``
instead of ``./sd-image.nix``.

``sudo nix-channel --update``

``sudo nixos-rebuild switch``

Fetches from cache.  Can consume 1G-3G of RAM on first go.  On a Pi 3 with 1G
of RAM, basically froze the Pi.  But thereafter, no more than 1G if things come
from cache.


Using ``deploy-rs`` With Remote Configuration
---------------------------------------------

I also got ``deploy-rs`` working in various ways to update the Pi remotely with
new packages and whatnot.

Working Method 1: Build locally, use aarch64 version of ``deploy-rs`` on target
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

The most reasonable method is to build locally, and use the ``aarch64`` version
of ``deploy-rs`` on the target.  It's slow (it builds using qemu, and doesn't
seem to pull much down from any binary cache) but it works and doesn't require
any significant amount of memory on the target system.  I tried this in part 1
but it wasn't working because I hadn't enabled ``aarch64-linux`` binary
emulation on my host system.

On NixOS host system, to set up ``aarch64`` emulation, you have to enable this
in your ``configuration.nix``::

    # run aarch64 binaries via qemu
    boot.binfmt.emulatedSystems = [ "aarch64-linux" ];

It's apparently possible to use a non-NixOS host system too; see
https://packages.ubuntu.com/bionic/qemu-user-binfmt (via
https://github.com/serokell/deploy-rs/issues/200).

You needn't make any changes to the ``nixos-pi-zero-2-w`` repository files
except to change the ``zero2w.nix`` file to reflect the packages and
configuration changes you want.

Log::

   $ nix run github:serokell/deploy-rs ".#zero2w" -- --ssh-user chrism --hostname 192.168.1.172
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Running checks for flake in .
   warning: Git tree '/home/chrism/projects/nixos-pi-zero-2' is dirty
   warning: unknown flake output 'deploy'
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Evaluating flake in .
   warning: Git tree '/home/chrism/projects/nixos-pi-zero-2' is dirty
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] The following profiles are going to be deployed:
   [zero2w.system]
   user = "root"
   ssh_user = "chrism"
   path = "/nix/store/psygac4lz9jgdj8qi9wv0kfg4xmpck72-activatable-nixos-system-nixos-24.05.20240225.2a34566"
   hostname = "zero2w"
   ssh_opts = []

   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Building profile `system` for node `zero2w`
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Copying profile `system` to node `zero2w`
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Activating profile `system` for node `zero2w`
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Creating activation waiter
   ‚≠ê ‚ÑπÔ∏è [activate] [INFO] Activating profile
   üëÄ ‚ÑπÔ∏è [wait] [INFO] Waiting for confirmation event...
   activating the configuration...
   setting up /etc...
   reloading user units for chrism...
   restarting sysinit-reactivation.target
   reloading the following units: dbus.service
   the following new units were started: sysinit-reactivation.target, systemd-tmpfiles-resetup.service
   ‚≠ê ‚ÑπÔ∏è [activate] [INFO] Activation succeeded!
   ‚≠ê ‚ÑπÔ∏è [activate] [INFO] Magic rollback is enabled, setting up confirmation hook...
   üëÄ ‚ÑπÔ∏è [wait] [INFO] Found canary file, done waiting!
   ‚≠ê ‚ÑπÔ∏è [activate] [INFO] Waiting for confirmation event...
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Success activating, attempting to confirm activation
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Deployment confirmed.

Working Method 2:  Build remotely
+++++++++++++++++++++++++++++++++

This will cause the remote system to build all the packages.  You needn't set
up ``aarch64-linux`` binary emulation on your host for this method or any other
form of binary emulation.  This probably won't work reliably for
very-low-memory systems like the Pi Zero 2 but it's probably fine for Pi 3/4/5.
Has similar memory requirements to using local config files on the Pi.

In ``nixos-pi-zero-2-w/flake.nix``::

  deploy = {
    user = "root";
    nodes = {
      zero2w = {
        hostname = "zero2w";
        profiles.system.path =
          deploy-rs.lib.aarch64-linux.activate.nixos self.nixosConfigurations.zero2w;
        # add this magic
        remoteBuild = true;
      };
    };
  };

Non-Working Method: Build locally, use x86_64 version of ``deploy-rs`` on target
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

In flake.nix::

  deploy = {
    user = "root";
    nodes = {
      zero2w = {
        hostname = "zero2w";
        profiles.system.path =
          # change this
          # deploy-rs.lib.aarch64-linux.activate.nixos self.nixosConfigurations.zero2w;
          # to this
          deploy-rs.lib.x86_64-linux.activate.nixos self.nixosConfigurations.zero2w;
      };
    };
  };

In zero2w.nix, uncomment::

  # run x86_64 binaries via qemu
  boot.binfmt.emulatedSystems = [ "x86_64-linux" ];

And comment::
  
  #nixpkgs.buildPlatform.system = "x86_64-linux";

Log::

   $ nix run github:serokell/deploy-rs ".#zero2w" -- --ssh-user chrism --hostname 192.168.1.171
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Running checks for flake in .
   warning: Git tree '/home/chrism/projects/nixos-pi-zero-2' is dirty
   warning: unknown flake output 'deploy'
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Evaluating flake in .
   warning: Git tree '/home/chrism/projects/nixos-pi-zero-2' is dirty
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] The following profiles are going to be deployed:
   [zero2w.system]
   user = "root"
   ssh_user = "chrism"
   path = "/nix/store/4n10n3v9p0hadw8nha12djyc6d3p4k17-activatable-nixos-system-nixos-24.05.20240225.2a34566"
   hostname = "zero2w"
   ssh_opts = []

   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Building profile `system` for node `zero2w`
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Copying profile `system` to node `zero2w`
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Activating profile `system` for node `zero2w`
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Creating activation waiter
   qemu-x86_64: QEMU internal SIGSEGV {code=MAPERR, addr=0x20}
   qemu-x86_64: QEMU internal SIGSEGV {code=MAPERR, addr=0x20}
   üöÄ ‚ùå [deploy] [ERROR] Activating over SSH resulted in a bad exit code: Some(255)
   üöÄ ‚ÑπÔ∏è [deploy] [INFO] Revoking previous deploys
   üöÄ ‚ùå [deploy] [ERROR] Deployment failed, rolled back to previous generation
  
